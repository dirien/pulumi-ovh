// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package me

import (
	"context"
	"reflect"

	"errors"
	"github.com/ovh/pulumi-ovh/sdk/go/ovh/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to create a custom installation template available for dedicated servers.
//
// ## Import
//
// Custom installation template available for dedicated servers can be imported using the `base_template_name`, `template_name` of the cluster, separated by "/" E.g.,
//
// bash
//
// ```sh
// $ pulumi import ovh:Me/installationTemplate:InstallationTemplate mytemplate base_template_name/template_name
// ```
type InstallationTemplate struct {
	pulumi.CustomResourceState

	// The name of an existing installation template, choose one among the list given by `getInstallationTemplates` datasource.
	BaseTemplateName pulumi.StringOutput `pulumi:"baseTemplateName"`
	// This template bit format (32 or 64).
	BitFormat pulumi.IntOutput `pulumi:"bitFormat"`
	// Category of this template (informative only). (basic, customer, hosting, other, readyToUse, virtualisation).
	Category      pulumi.StringOutput                        `pulumi:"category"`
	Customization InstallationTemplateCustomizationPtrOutput `pulumi:"customization"`
	// information about this template.
	Description pulumi.StringOutput `pulumi:"description"`
	// the distribution this template is based on.
	Distribution pulumi.StringOutput `pulumi:"distribution"`
	// after this date, install of this template will not be possible at OVH
	EndOfInstall pulumi.StringOutput `pulumi:"endOfInstall"`
	// this template family type.
	Family pulumi.StringOutput `pulumi:"family"`
	// Filesystems available.
	Filesystems pulumi.StringArrayOutput `pulumi:"filesystems"`
	// This distribution supports hardware raid configuration through the OVHcloud API. Deprecated, will be removed in next release.
	//
	// Deprecated: This will be deprecated in the next release
	HardRaidConfiguration pulumi.BoolOutput                        `pulumi:"hardRaidConfiguration"`
	Inputs                InstallationTemplateInputTypeArrayOutput `pulumi:"inputs"`
	// Whether this distribution supports Logical Volumes (Linux LVM)
	LvmReady pulumi.BoolOutput `pulumi:"lvmReady"`
	// Partitioning customization is not available for this OS template
	NoPartitioning pulumi.BoolOutput `pulumi:"noPartitioning"`
	// Remove default partition schemes at creation.
	RemoveDefaultPartitionSchemes pulumi.BoolOutput `pulumi:"removeDefaultPartitionSchemes"`
	// Partitioning customization is available but limited to mirroring for this OS template
	SoftRaidOnlyMirroring pulumi.BoolOutput `pulumi:"softRaidOnlyMirroring"`
	// this template subfamily type
	Subfamily pulumi.StringOutput `pulumi:"subfamily"`
	// This template name.
	TemplateName pulumi.StringOutput `pulumi:"templateName"`
}

// NewInstallationTemplate registers a new resource with the given unique name, arguments, and options.
func NewInstallationTemplate(ctx *pulumi.Context,
	name string, args *InstallationTemplateArgs, opts ...pulumi.ResourceOption) (*InstallationTemplate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.BaseTemplateName == nil {
		return nil, errors.New("invalid value for required argument 'BaseTemplateName'")
	}
	if args.TemplateName == nil {
		return nil, errors.New("invalid value for required argument 'TemplateName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource InstallationTemplate
	err := ctx.RegisterResource("ovh:Me/installationTemplate:InstallationTemplate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstallationTemplate gets an existing InstallationTemplate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstallationTemplate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstallationTemplateState, opts ...pulumi.ResourceOption) (*InstallationTemplate, error) {
	var resource InstallationTemplate
	err := ctx.ReadResource("ovh:Me/installationTemplate:InstallationTemplate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering InstallationTemplate resources.
type installationTemplateState struct {
	// The name of an existing installation template, choose one among the list given by `getInstallationTemplates` datasource.
	BaseTemplateName *string `pulumi:"baseTemplateName"`
	// This template bit format (32 or 64).
	BitFormat *int `pulumi:"bitFormat"`
	// Category of this template (informative only). (basic, customer, hosting, other, readyToUse, virtualisation).
	Category      *string                            `pulumi:"category"`
	Customization *InstallationTemplateCustomization `pulumi:"customization"`
	// information about this template.
	Description *string `pulumi:"description"`
	// the distribution this template is based on.
	Distribution *string `pulumi:"distribution"`
	// after this date, install of this template will not be possible at OVH
	EndOfInstall *string `pulumi:"endOfInstall"`
	// this template family type.
	Family *string `pulumi:"family"`
	// Filesystems available.
	Filesystems []string `pulumi:"filesystems"`
	// This distribution supports hardware raid configuration through the OVHcloud API. Deprecated, will be removed in next release.
	//
	// Deprecated: This will be deprecated in the next release
	HardRaidConfiguration *bool                           `pulumi:"hardRaidConfiguration"`
	Inputs                []InstallationTemplateInputType `pulumi:"inputs"`
	// Whether this distribution supports Logical Volumes (Linux LVM)
	LvmReady *bool `pulumi:"lvmReady"`
	// Partitioning customization is not available for this OS template
	NoPartitioning *bool `pulumi:"noPartitioning"`
	// Remove default partition schemes at creation.
	RemoveDefaultPartitionSchemes *bool `pulumi:"removeDefaultPartitionSchemes"`
	// Partitioning customization is available but limited to mirroring for this OS template
	SoftRaidOnlyMirroring *bool `pulumi:"softRaidOnlyMirroring"`
	// this template subfamily type
	Subfamily *string `pulumi:"subfamily"`
	// This template name.
	TemplateName *string `pulumi:"templateName"`
}

type InstallationTemplateState struct {
	// The name of an existing installation template, choose one among the list given by `getInstallationTemplates` datasource.
	BaseTemplateName pulumi.StringPtrInput
	// This template bit format (32 or 64).
	BitFormat pulumi.IntPtrInput
	// Category of this template (informative only). (basic, customer, hosting, other, readyToUse, virtualisation).
	Category      pulumi.StringPtrInput
	Customization InstallationTemplateCustomizationPtrInput
	// information about this template.
	Description pulumi.StringPtrInput
	// the distribution this template is based on.
	Distribution pulumi.StringPtrInput
	// after this date, install of this template will not be possible at OVH
	EndOfInstall pulumi.StringPtrInput
	// this template family type.
	Family pulumi.StringPtrInput
	// Filesystems available.
	Filesystems pulumi.StringArrayInput
	// This distribution supports hardware raid configuration through the OVHcloud API. Deprecated, will be removed in next release.
	//
	// Deprecated: This will be deprecated in the next release
	HardRaidConfiguration pulumi.BoolPtrInput
	Inputs                InstallationTemplateInputTypeArrayInput
	// Whether this distribution supports Logical Volumes (Linux LVM)
	LvmReady pulumi.BoolPtrInput
	// Partitioning customization is not available for this OS template
	NoPartitioning pulumi.BoolPtrInput
	// Remove default partition schemes at creation.
	RemoveDefaultPartitionSchemes pulumi.BoolPtrInput
	// Partitioning customization is available but limited to mirroring for this OS template
	SoftRaidOnlyMirroring pulumi.BoolPtrInput
	// this template subfamily type
	Subfamily pulumi.StringPtrInput
	// This template name.
	TemplateName pulumi.StringPtrInput
}

func (InstallationTemplateState) ElementType() reflect.Type {
	return reflect.TypeOf((*installationTemplateState)(nil)).Elem()
}

type installationTemplateArgs struct {
	// The name of an existing installation template, choose one among the list given by `getInstallationTemplates` datasource.
	BaseTemplateName string                             `pulumi:"baseTemplateName"`
	Customization    *InstallationTemplateCustomization `pulumi:"customization"`
	// Remove default partition schemes at creation.
	RemoveDefaultPartitionSchemes *bool `pulumi:"removeDefaultPartitionSchemes"`
	// This template name.
	TemplateName string `pulumi:"templateName"`
}

// The set of arguments for constructing a InstallationTemplate resource.
type InstallationTemplateArgs struct {
	// The name of an existing installation template, choose one among the list given by `getInstallationTemplates` datasource.
	BaseTemplateName pulumi.StringInput
	Customization    InstallationTemplateCustomizationPtrInput
	// Remove default partition schemes at creation.
	RemoveDefaultPartitionSchemes pulumi.BoolPtrInput
	// This template name.
	TemplateName pulumi.StringInput
}

func (InstallationTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*installationTemplateArgs)(nil)).Elem()
}

type InstallationTemplateInput interface {
	pulumi.Input

	ToInstallationTemplateOutput() InstallationTemplateOutput
	ToInstallationTemplateOutputWithContext(ctx context.Context) InstallationTemplateOutput
}

func (*InstallationTemplate) ElementType() reflect.Type {
	return reflect.TypeOf((**InstallationTemplate)(nil)).Elem()
}

func (i *InstallationTemplate) ToInstallationTemplateOutput() InstallationTemplateOutput {
	return i.ToInstallationTemplateOutputWithContext(context.Background())
}

func (i *InstallationTemplate) ToInstallationTemplateOutputWithContext(ctx context.Context) InstallationTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationTemplateOutput)
}

// InstallationTemplateArrayInput is an input type that accepts InstallationTemplateArray and InstallationTemplateArrayOutput values.
// You can construct a concrete instance of `InstallationTemplateArrayInput` via:
//
//	InstallationTemplateArray{ InstallationTemplateArgs{...} }
type InstallationTemplateArrayInput interface {
	pulumi.Input

	ToInstallationTemplateArrayOutput() InstallationTemplateArrayOutput
	ToInstallationTemplateArrayOutputWithContext(context.Context) InstallationTemplateArrayOutput
}

type InstallationTemplateArray []InstallationTemplateInput

func (InstallationTemplateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InstallationTemplate)(nil)).Elem()
}

func (i InstallationTemplateArray) ToInstallationTemplateArrayOutput() InstallationTemplateArrayOutput {
	return i.ToInstallationTemplateArrayOutputWithContext(context.Background())
}

func (i InstallationTemplateArray) ToInstallationTemplateArrayOutputWithContext(ctx context.Context) InstallationTemplateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationTemplateArrayOutput)
}

// InstallationTemplateMapInput is an input type that accepts InstallationTemplateMap and InstallationTemplateMapOutput values.
// You can construct a concrete instance of `InstallationTemplateMapInput` via:
//
//	InstallationTemplateMap{ "key": InstallationTemplateArgs{...} }
type InstallationTemplateMapInput interface {
	pulumi.Input

	ToInstallationTemplateMapOutput() InstallationTemplateMapOutput
	ToInstallationTemplateMapOutputWithContext(context.Context) InstallationTemplateMapOutput
}

type InstallationTemplateMap map[string]InstallationTemplateInput

func (InstallationTemplateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InstallationTemplate)(nil)).Elem()
}

func (i InstallationTemplateMap) ToInstallationTemplateMapOutput() InstallationTemplateMapOutput {
	return i.ToInstallationTemplateMapOutputWithContext(context.Background())
}

func (i InstallationTemplateMap) ToInstallationTemplateMapOutputWithContext(ctx context.Context) InstallationTemplateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstallationTemplateMapOutput)
}

type InstallationTemplateOutput struct{ *pulumi.OutputState }

func (InstallationTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstallationTemplate)(nil)).Elem()
}

func (o InstallationTemplateOutput) ToInstallationTemplateOutput() InstallationTemplateOutput {
	return o
}

func (o InstallationTemplateOutput) ToInstallationTemplateOutputWithContext(ctx context.Context) InstallationTemplateOutput {
	return o
}

// The name of an existing installation template, choose one among the list given by `getInstallationTemplates` datasource.
func (o InstallationTemplateOutput) BaseTemplateName() pulumi.StringOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringOutput { return v.BaseTemplateName }).(pulumi.StringOutput)
}

// This template bit format (32 or 64).
func (o InstallationTemplateOutput) BitFormat() pulumi.IntOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.IntOutput { return v.BitFormat }).(pulumi.IntOutput)
}

// Category of this template (informative only). (basic, customer, hosting, other, readyToUse, virtualisation).
func (o InstallationTemplateOutput) Category() pulumi.StringOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringOutput { return v.Category }).(pulumi.StringOutput)
}

func (o InstallationTemplateOutput) Customization() InstallationTemplateCustomizationPtrOutput {
	return o.ApplyT(func(v *InstallationTemplate) InstallationTemplateCustomizationPtrOutput { return v.Customization }).(InstallationTemplateCustomizationPtrOutput)
}

// information about this template.
func (o InstallationTemplateOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// the distribution this template is based on.
func (o InstallationTemplateOutput) Distribution() pulumi.StringOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringOutput { return v.Distribution }).(pulumi.StringOutput)
}

// after this date, install of this template will not be possible at OVH
func (o InstallationTemplateOutput) EndOfInstall() pulumi.StringOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringOutput { return v.EndOfInstall }).(pulumi.StringOutput)
}

// this template family type.
func (o InstallationTemplateOutput) Family() pulumi.StringOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringOutput { return v.Family }).(pulumi.StringOutput)
}

// Filesystems available.
func (o InstallationTemplateOutput) Filesystems() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringArrayOutput { return v.Filesystems }).(pulumi.StringArrayOutput)
}

// This distribution supports hardware raid configuration through the OVHcloud API. Deprecated, will be removed in next release.
//
// Deprecated: This will be deprecated in the next release
func (o InstallationTemplateOutput) HardRaidConfiguration() pulumi.BoolOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.BoolOutput { return v.HardRaidConfiguration }).(pulumi.BoolOutput)
}

func (o InstallationTemplateOutput) Inputs() InstallationTemplateInputTypeArrayOutput {
	return o.ApplyT(func(v *InstallationTemplate) InstallationTemplateInputTypeArrayOutput { return v.Inputs }).(InstallationTemplateInputTypeArrayOutput)
}

// Whether this distribution supports Logical Volumes (Linux LVM)
func (o InstallationTemplateOutput) LvmReady() pulumi.BoolOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.BoolOutput { return v.LvmReady }).(pulumi.BoolOutput)
}

// Partitioning customization is not available for this OS template
func (o InstallationTemplateOutput) NoPartitioning() pulumi.BoolOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.BoolOutput { return v.NoPartitioning }).(pulumi.BoolOutput)
}

// Remove default partition schemes at creation.
func (o InstallationTemplateOutput) RemoveDefaultPartitionSchemes() pulumi.BoolOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.BoolOutput { return v.RemoveDefaultPartitionSchemes }).(pulumi.BoolOutput)
}

// Partitioning customization is available but limited to mirroring for this OS template
func (o InstallationTemplateOutput) SoftRaidOnlyMirroring() pulumi.BoolOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.BoolOutput { return v.SoftRaidOnlyMirroring }).(pulumi.BoolOutput)
}

// this template subfamily type
func (o InstallationTemplateOutput) Subfamily() pulumi.StringOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringOutput { return v.Subfamily }).(pulumi.StringOutput)
}

// This template name.
func (o InstallationTemplateOutput) TemplateName() pulumi.StringOutput {
	return o.ApplyT(func(v *InstallationTemplate) pulumi.StringOutput { return v.TemplateName }).(pulumi.StringOutput)
}

type InstallationTemplateArrayOutput struct{ *pulumi.OutputState }

func (InstallationTemplateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InstallationTemplate)(nil)).Elem()
}

func (o InstallationTemplateArrayOutput) ToInstallationTemplateArrayOutput() InstallationTemplateArrayOutput {
	return o
}

func (o InstallationTemplateArrayOutput) ToInstallationTemplateArrayOutputWithContext(ctx context.Context) InstallationTemplateArrayOutput {
	return o
}

func (o InstallationTemplateArrayOutput) Index(i pulumi.IntInput) InstallationTemplateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *InstallationTemplate {
		return vs[0].([]*InstallationTemplate)[vs[1].(int)]
	}).(InstallationTemplateOutput)
}

type InstallationTemplateMapOutput struct{ *pulumi.OutputState }

func (InstallationTemplateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InstallationTemplate)(nil)).Elem()
}

func (o InstallationTemplateMapOutput) ToInstallationTemplateMapOutput() InstallationTemplateMapOutput {
	return o
}

func (o InstallationTemplateMapOutput) ToInstallationTemplateMapOutputWithContext(ctx context.Context) InstallationTemplateMapOutput {
	return o
}

func (o InstallationTemplateMapOutput) MapIndex(k pulumi.StringInput) InstallationTemplateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *InstallationTemplate {
		return vs[0].(map[string]*InstallationTemplate)[vs[1].(string)]
	}).(InstallationTemplateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstallationTemplateInput)(nil)).Elem(), &InstallationTemplate{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstallationTemplateArrayInput)(nil)).Elem(), InstallationTemplateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstallationTemplateMapInput)(nil)).Elem(), InstallationTemplateMap{})
	pulumi.RegisterOutputType(InstallationTemplateOutput{})
	pulumi.RegisterOutputType(InstallationTemplateArrayOutput{})
	pulumi.RegisterOutputType(InstallationTemplateMapOutput{})
}
